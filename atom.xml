<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>记录点滴</subtitle>
  <link href="https://levinhen.github.io/atom.xml" rel="self"/>
  
  <link href="https://levinhen.github.io/"/>
  <updated>2021-02-24T03:16:31.177Z</updated>
  <id>https://levinhen.github.io/</id>
  
  <author>
    <name>Levinhen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法题小结</title>
    <link href="https://levinhen.github.io/2021/02/03/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
    <id>https://levinhen.github.io/2021/02/03/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B0%8F%E7%BB%93/</id>
    <published>2021-02-03T13:26:41.000Z</published>
    <updated>2021-02-24T03:16:31.177Z</updated>
    
    <content type="html"><![CDATA[<h4 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h4><p>解题思想是使用滑动窗口，在这之中，运用字幕的ASCII码作为vector的索引挺让人眼前一亮。</p><p><img src="https://i.loli.net/2021/02/06/E5o1BhRjvaeVMit.png" alt="8b7cac826e572c65f8b77e0f380eaa93ab665857a8e916bc4ea36b7765eafc55-图片.png" title="滑动窗口"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; s.size(); j++) &#123;</span><br><span class="line">i = max(i, m[s[j]]);</span><br><span class="line">m[s[j]] = j + <span class="number">1</span>;</span><br><span class="line">ans = max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O($n^2$),空间复杂度为O(1)</p><h4 id="动态规划——最长回文子串"><a href="#动态规划——最长回文子串" class="headerlink" title="动态规划——最长回文子串"></a>动态规划——最长回文子串</h4><p>在邓公的书本上是没有发现动态规划相关内容的，我在<a href="https://www.zhihu.com/question/23995189">知乎的这里</a>发现了动态规划的讲解，非常通俗易懂。</p><p>在我理解的动态规划，就是另一种的贪心算法罢了？只不过动态规划是从小积累到大，强调记忆性，而贪心算法是将问题减而治之。</p><h4 id="不修改数组在-n-1-的数组中找出重复的数字"><a href="#不修改数组在-n-1-的数组中找出重复的数字" class="headerlink" title="不修改数组在[n+1]的数组中找出重复的数字"></a>不修改数组在[n+1]的数组中找出重复的数字</h4><p>在[n+1]数组中，想要不修改就找出数字，分为采用辅助数组和不采用两种方法。空间复杂度为O(n)和O(1)。只是不采用辅助数组要求数据的范围是1~n，换言之就是能确定一定有多余的数。</p><h4 id="寻找二进制数字的1的个数"><a href="#寻找二进制数字的1的个数" class="headerlink" title="寻找二进制数字的1的个数"></a>寻找二进制数字的1的个数</h4><p>在这样一个数字中，很容易想到的就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">除以2，除法速度非常慢</span><br><span class="line">往右移位，每次n位，且与n个1进行与运算，然而这种算法遇到负数就会溢出变成全为1的二进制数</span><br><span class="line">让做与运算的数往左移位，这样的方法能够有效避免溢出</span><br><span class="line">最好的方法是每次减1，然后与1做位运算</span><br><span class="line">##这种方法的时间复杂度比O(n)更小一点，目标数字有多少位1，方法所需要的处理次数就为多少</span><br></pre></td></tr></table></figure><h4 id="排序算法——最小的k个数"><a href="#排序算法——最小的k个数" class="headerlink" title="排序算法——最小的k个数"></a>排序算法——最小的k个数</h4><p><em>输入n个整数，找出其中最小的k个数</em></p><p>解法一：改进的快速排序</p><p>因为快速排序所得到的输出序列具有内在的大小顺位关系，于是想到是否可以舍弃这个大小关系以获得更快速的算法。在快速排序里面，每次排序完都会对哨兵的左、右子数组都进行递归，然而只需要对哨兵的index进行判断，判断是否为k，不相等时再相应对其中一侧递归的使用Partition函数即可。</p><p>解法二：不能更改数组时</p><p>选用一个合适的数据结构用以存放k个数，这样每次读取输入一个数只需要与现存的k个数中最大的数进行比较，小就替换，大就舍去。这个方法适用于海量的数据(不能全部存放在内存中的数据)，因为内存需要的空间只是k个数的空间。C++中以红黑树为基础的multiset就不失为好选择。</p><h4 id="二叉树与双向链表"><a href="#二叉树与双向链表" class="headerlink" title="二叉树与双向链表"></a>二叉树与双向链表</h4><p><em>将二叉树转变成双向链表</em></p><p>这道题没什么难的，就是出现了一个很奇怪的现象，在VisualStudio上能安全运行的代码居然在leetcode的在线编译器上报错了<code>member access within null pointer of type &#39;Node&#39;</code>下接代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">Node* left;</span><br><span class="line">Node* right;</span><br><span class="line"></span><br><span class="line">Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">val = _val;</span><br><span class="line">left = <span class="literal">NULL</span>;</span><br><span class="line">right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">int</span> _val, Node* _left, Node* _right) &#123;</span><br><span class="line">val = _val;</span><br><span class="line">left = _left;</span><br><span class="line">right = _right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">Node* Last_node = <span class="literal">nullptr</span>;</span><br><span class="line">BuildTree(root, &amp;Last_node);</span><br><span class="line"></span><br><span class="line">Node* head = Last_node;</span><br><span class="line"><span class="keyword">while</span> (head-&gt;left &amp;&amp; head) &#123;</span><br><span class="line">head = head-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(Node* node, Node** Last_node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">Node* current = node;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;left) BuildTree(current-&gt;left, Last_node);</span><br><span class="line">current-&gt;left = *Last_node;</span><br><span class="line"><span class="keyword">if</span> (*Last_node) (*Last_node)-&gt;right = current;</span><br><span class="line">*Last_node = current;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;right) BuildTree(current-&gt;right, Last_node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目前为止尚未弄明白这到底是怎么一回事。(初步推测是没有将整个双向链表的头和尾连接起来)</p><p>在leetcode的在线ide上这玩意又是接收了空指针又是栈溢出，很烦，然后再po一个能够运行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Node* head, *tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root); </span><br><span class="line">        head -&gt; left = tail; </span><br><span class="line">        tail -&gt; right = head; </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root -&gt; left);</span><br><span class="line">        <span class="keyword">if</span>(!tail) &#123;</span><br><span class="line">            head = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tail -&gt; right = root;</span><br><span class="line">            root -&gt; left = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = root;</span><br><span class="line">        inorder(root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="A-star-寻路算法"><a href="#A-star-寻路算法" class="headerlink" title="A-star 寻路算法"></a>A-star 寻路算法</h4><p>虽然不知道能不能算在算法题里面，但是就这么算了，事实上关于A星寻路算法，理解挺简单的。具体可以参考<a href="https://www.jianshu.com/p/65282bd32391">A-star</a>，然后是网友做出来的一个<a href="https://anseyuyin.github.io/AStar-Process/demo">算法可视化</a>。</p><p>感觉算法总体有一些优化空间，但是我暂时优化不出来，具体是关于怎么使用地图的整体。</p><h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><p>这个题目挺有趣的，第一个做法暴力解法超时了，看题解发现有三种方法可以做出来，这里只贴出我使用的单挑递减栈的代码。</p><p>一、双指针</p><p><img src="https://i.loli.net/2021/02/24/WFIejOzPrHUCxLR.png" alt="1614045759-jjZdVw-file_1614045758988.png"></p><p>在每一列寻找左侧最高柱与右侧最高柱，比较两者中的最小值再减去本列的高度乘以宽度1就是本列的雨水蓄积量了。</p><p>二、动态规划</p><p>当前位置，左边的最高高度，是前一个位置的最高高度和本高度的最大值。<br>即从左向右遍历：<code>maxLeft[i] = max(height[i], maxLeft[i - 1]);</code><br>从右向左遍历：<code>maxRight[i] = max(height[i], maxRight[i + 1]);</code><br>这样就找到递推公式。</p><p>三、单调递减栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.size(); i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() &amp;&amp; height[i] &gt; height[<span class="built_in">stack</span>.top()]) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="built_in">stack</span>.top();</span><br><span class="line"><span class="built_in">stack</span>.pop();</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> h = min(height[i], height[<span class="built_in">stack</span>.top()]) - height[mid];</span><br><span class="line"><span class="keyword">int</span> w = i - <span class="built_in">stack</span>.top() - <span class="number">1</span>;</span><br><span class="line">sum += h * w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stack</span>.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h4&gt;&lt;p&gt;解题思想是使用滑动窗口，在这之中，运用字幕的ASCII码作为vector的索</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++相关知识</title>
    <link href="https://levinhen.github.io/2021/02/03/C-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>https://levinhen.github.io/2021/02/03/C-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</id>
    <published>2021-02-03T06:19:49.000Z</published>
    <updated>2021-02-18T16:19:10.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-相关知识"><a href="#C-相关知识" class="headerlink" title="C++相关知识"></a>C++相关知识</h2><p>在做题的时候是Java和C++都有的，故复习一下C++。</p><p>1、箭头运算符和点运算符，点运算符的左侧对象为实例，箭头运算符为指针。</p><p>2、使用new初始化char[]的时候要+1，给<code>\0</code>预留位置。</p><p>3、在合并两个数组的时候，从前往后复制往往需要移动多次，但是从后往前移动就没有这种烦恼。</p><p>4、很显然的，在计算时少用乘除法，多用位运算，数学上等价的运算，效率上却有着千差万别。</p><p>5、在直接将字符数组中的数字转换成int型需要减一个<code>&#39;0&#39;</code>,这个是减去字符0的ascii码。</p><p>6、C++ STL库里的Partition函数与快速排序还是有点差别的。</p><p>7、<code>vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;&#125;&#125;;</code>如果直接使用<code>matrix.empty()</code>判断为非空。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-相关知识&quot;&gt;&lt;a href=&quot;#C-相关知识&quot; class=&quot;headerlink&quot; title=&quot;C++相关知识&quot;&gt;&lt;/a&gt;C++相关知识&lt;/h2&gt;&lt;p&gt;在做题的时候是Java和C++都有的，故复习一下C++。&lt;/p&gt;
&lt;p&gt;1、箭头运算符和点运算符，点运算</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java相关知识</title>
    <link href="https://levinhen.github.io/2021/02/02/java%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>https://levinhen.github.io/2021/02/02/java%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</id>
    <published>2021-02-02T03:22:22.000Z</published>
    <updated>2021-02-02T16:58:23.526Z</updated>
    
    <content type="html"><![CDATA[<p>这是在学习算法(第4版)里遇到的一些比较重要的知识点。</p><h2 id="Java篇"><a href="#Java篇" class="headerlink" title="Java篇"></a>Java篇</h2><h4 id="抽象数据类型的实现"><a href="#抽象数据类型的实现" class="headerlink" title="抽象数据类型的实现"></a>抽象数据类型的实现</h4><p>每个java类都至少含有一个构造函数，且其中的实例变量像是在一个普通的函数(C++)中的全局变量，但是是对每一个实例对象而言的。</p><p>关于api的考量，只为用例提供它们所需要的，这是设计api的指导思想。而在整个算法书中并不会使用接口继承，为了便于理解。但使用接口能方便进行比较和迭代。</p><p>Java的一个特点就是它不允许修改引用的策略，这种策略使Java能高效自动地回收垃圾。且有一个关键字<code>final</code>类似于C++的<code>const</code>，猜测由于没有指针的存在，故也没有顶层与底层的区别？但是感觉Java的引用和C++的指针在某些地方又有些重合的意味，有待深究。<br>姑且得到了答案，Java的引用被称作<strong>安全指针</strong>。因为对引用的创建于改变的方法都只有一种所以称为安全指针。</p><p>关于定容栈，书中提到Java是无法创建泛型数组的，需要使用类型转换，可是，难以理解这一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=(Item[]) <span class="keyword">new</span> Object[cap];</span><br></pre></td></tr></table></figure><p>书中提到了实现动态数组就是增与减，但是我觉得邓公的书更完善，并不一定每种情况的增量都是两倍，有些时候的确加固定值会更好。</p><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p>在给VS Code安装Java环境的时候，遇到了版本不匹配的问题，需要把旧版本删了，推荐用官方的删除工具，能把Java的高速缓存也清空了。<a href="https://www.java.com/zh-CN/download/uninstalltool.jsp">官网卸载工具</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是在学习算法(第4版)里遇到的一些比较重要的知识点。&lt;/p&gt;
&lt;h2 id=&quot;Java篇&quot;&gt;&lt;a href=&quot;#Java篇&quot; class=&quot;headerlink&quot; title=&quot;Java篇&quot;&gt;&lt;/a&gt;Java篇&lt;/h2&gt;&lt;h4 id=&quot;抽象数据类型的实现&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://levinhen.github.io/2021/01/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://levinhen.github.io/2021/01/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-01-25T08:37:43.000Z</published>
    <updated>2021-01-27T03:25:07.028Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统实际上的作用，取得物理资源(如CPU、内存与硬盘)，对它们虚拟化<code>virtualize</code>，处理与并发<code>concurrency</code>有关的问题，再持久地<code>persistently</code>存储文件。</p><p>在整个操作系统的过程中，抽象是非常重要的一个手段，有时候我们用了可能都不知道。</p><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>抽象：进程</p><p>渐渐的CPU虚拟化是看完了，可是在这些天刷题的过程中觉得还挺难，于是又回去看算法了。</p><hr><p>​                                            2021.1.27</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;操作系统实际上的作用，取得物理资源(如CPU、内存与硬盘)，对它们虚拟化&lt;code&gt;virtualize&lt;/code&gt;，处理与并发&lt;code&gt;concurrency&lt;/code&gt;有关的问题，再持久地&lt;code&gt;persistently&lt;/code&gt;存储文件。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法总结（一）</title>
    <link href="https://levinhen.github.io/2021/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://levinhen.github.io/2021/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-16T03:23:33.000Z</published>
    <updated>2021-01-27T08:33:07.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构与算法思想总结"><a href="#数据结构与算法思想总结" class="headerlink" title="数据结构与算法思想总结"></a>数据结构与算法思想总结</h2><p>我是跟着邓俊辉老师学习的数据结构与算法，第一次学习真的感觉视野增长了好多，很多数据结构以前都只是听过名字，也就是说有很多耳熟能详的名字，但却说不出个所以然。因此，通过邓老师的数据结构与算法入门之后，感觉还是非常的不错的。于是想在这里，重新回顾一遍我所学过的知识，也顺便总结一下。</p><p>这一次是想跟着挺有名的一本书叫algorithms的走一遍的，可是刚开始就要先学一小段java，后来想想打算把手头的任务都结束再去学一遍，毕竟算法学个几遍也不稀奇嘛。</p><p>说到底还是“得益”我没有做笔记，不得不重新再看一遍了。但是我也只是想做一做有关思想方面的总结，如果说全部的内容那真的算是很多了，如果有空再做吧。</p><h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><p>我觉得在绪论里面已经有很多很重要的思想了，所以我想单独谈一谈绪论。</p><p>在绪论里面，我们能够接触到关于<code>递归</code>与<code>迭代</code>的概念，这种重要的概念也不需要多做解释了吧。</p><p>值得一提的就是<code>尾递归</code>这种概念，算法中的所有实例都终止于此调用，才能称为尾递归，而尾递归是能一定能转化为迭代的形式的。关于递归，很多人的第一印象就是慢(虽然其实它并不是很慢)，但是慢的原因主要还是如下两点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fib():存在大量重复计算</span><br><span class="line">我们可以尝试通过：</span><br><span class="line">记忆:将计算过的实例制表备查</span><br><span class="line">动态规划:由自顶而下递归更改为自下而上迭代</span><br><span class="line">LCS:有歧义的存在</span><br></pre></td></tr></table></figure><p>随后是关于度量算法的好坏的，自然而然的，度量算法的好坏从时间与空间两种角度想，我们会采用渐进分析来尝试表示算法的复杂度。去用一个式子逼近想要得到的函数，这也时一种非常重要的思想。</p><p>在邓老师的课程中，关于计算的一种挺重要的手段就是<code>封底估算</code>，一些重要的估算结果很容易让人记住。就比如，<br>$$<br>一天约等于10^5秒，三生三世约等于10^{10}秒。<br>$$<br>然后还有关于问题的两种最经典的解决方式，<code>分而治之</code>与<code>减而治之</code>。这两种解决问题的方式其实也贯穿全书，也无需多做解释。</p><p>最后一个我认为最主要的思想就是<code>ADT(抽象数据类型)</code>遵循”数据隐藏”，就如同大家最喜欢的”黑盒子”思想，将实现细节隐藏，只保留对应的功能接口。这种模块化的思考方式，在我的电气学习旅途中也是最主要的思想。是将传统的数据以及组合的结构方式抽象出来，跳脱出语言的范畴，这种思想也是贯穿全书的。</p><h3 id="数据结构总结"><a href="#数据结构总结" class="headerlink" title="数据结构总结"></a>数据结构总结</h3><p>在我的理解中，各种各样的数据结构并不是毫无来由的，我们可以根据对性能或者成本的各种考量来催生出对应的各种数据结构。</p><h4 id="向量与列表"><a href="#向量与列表" class="headerlink" title="向量与列表"></a>向量与列表</h4><h5 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h5><p>第一次，我把详细的关于该数据结构的操作接口以及对应的实现完全实现一遍，而后面的数据结构我并不会再这样实现一遍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> rank;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFALUT_CAPACITY 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">rank _size; <span class="keyword">int</span> _capacity; T* _elem;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyfrom</span><span class="params">(T <span class="keyword">const</span>* A, rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shrink</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bubble</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">max</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionsort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">partition</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Vector(<span class="keyword">int</span> c = DEFALUT_CAPACITY, <span class="keyword">int</span> s = <span class="number">0</span>, T v = <span class="number">0</span>) &#123;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity = c];</span><br><span class="line"><span class="keyword">for</span> (_size = <span class="number">0</span>; _size &lt; s; _elem[_size++]);</span><br><span class="line">&#125;</span><br><span class="line">Vector(T <span class="keyword">const</span>* A, rank n) &#123; copyfrom(A, <span class="number">0</span>, n); &#125;</span><br><span class="line">Vector(T <span class="keyword">const</span>* A, rank lo, rank hi) &#123; copyfrom(A, lo, hi); &#125;</span><br><span class="line">Vector(Vector&lt;T&gt; <span class="keyword">const</span>&amp; V) &#123; copyfrom(V._elem, <span class="number">0</span>, V._size); &#125;</span><br><span class="line">Vector(Vector&lt;T&gt; <span class="keyword">const</span>&amp; V, rank lo, rank hi) &#123; copyfrom(V._elem, <span class="number">0</span>, V._size); &#125;</span><br><span class="line"></span><br><span class="line">~Vector()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] _elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">rank <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_size; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">disordered</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">find</span><span class="params">(T <span class="keyword">const</span>&amp; e)</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> find(e, <span class="number">0</span>, _size); &#125;</span><br><span class="line"><span class="function">rank <span class="title">find</span><span class="params">(T <span class="keyword">const</span>&amp; e, rank lo, rank hi)</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">search</span><span class="params">(T <span class="keyword">const</span>&amp; e)</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="number">0</span> &gt;= _size) ? <span class="number">-1</span> : search(e, <span class="number">0</span>, _size); &#125;</span><br><span class="line"><span class="function">rank <span class="title">search</span><span class="params">(T <span class="keyword">const</span>&amp; e, rank lo, rank hi)</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>[] (rank r)<span class="keyword">const</span>;</span><br><span class="line">Vector&lt;T&gt; &amp; <span class="keyword">operator</span>=(Vector&lt;T&gt; <span class="keyword">const</span>&amp;);</span><br><span class="line"><span class="function">rank <span class="title">remove</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">remove</span><span class="params">(rank r)</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">insert</span><span class="params">(rank r, T <span class="keyword">const</span>&amp; e)</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">insert</span><span class="params">(T <span class="keyword">const</span>&amp; e)</span> </span>&#123; <span class="keyword">return</span> insert(_size, e); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123; sort(<span class="number">0</span>, _size); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsort</span><span class="params">()</span> </span>&#123; unsort(<span class="number">0</span>,_size); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deduplicate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">( <span class="keyword">void</span> (*) ( T&amp; ) )</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VST&gt;<span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(VST&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在向量这一种数据结构中，特别地在有序向量这种数据结构中，我们能够”循秩访问”(call-by-rank)我想，这也是向量(数组)的特别之处了吧。</p><p>写到这突然想了想，觉得不想写了，这种总结性质的笔记果然我只适合存在脑子里，不适合大喇喇的写出来。</p><p>又开始看算法了，继续写。</p><p>在学习基础的java语法的时候，书里面有这样一段话：<code>变量关联的是指向对象的引用而非数据类型的值本身</code>还是挺难理解的。后来，查了查，嗯，这不就是返回地址嘛，类似于指针。但是关于实例方法与静态方法，始终有些疑惑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构与算法思想总结&quot;&gt;&lt;a href=&quot;#数据结构与算法思想总结&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法思想总结&quot;&gt;&lt;/a&gt;数据结构与算法思想总结&lt;/h2&gt;&lt;p&gt;我是跟着邓俊辉老师学习的数据结构与算法，第一次学习真的感觉视野增长了</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://levinhen.github.io/2021/01/14/hello-world/"/>
    <id>https://levinhen.github.io/2021/01/14/hello-world/</id>
    <published>2021-01-14T13:21:30.575Z</published>
    <updated>2021-01-14T14:38:02.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><hr><h3 id="记录在blog创建过程中出现的问题"><a href="#记录在blog创建过程中出现的问题" class="headerlink" title="记录在blog创建过程中出现的问题"></a>记录在blog创建过程中出现的问题</h3><p>首先，当然是blog的创立，我参考了很多，最后决定使用github的github pages服务，具体则是依靠Hexo建立的站点。</p><p>github pages可以使用Git来控制，不得不说这是相当方便了。</p><p>使用Hexo的过程在这：</p><p><code>npm install -g hexo-cli</code>  在这里可以选择是否局部安装<code>hexo</code>包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就几句简单的命令而已，随后再安装<code>hexo</code>的<code>git</code>安装包部分就完全OK了。之后的步骤就是配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: https:&#x2F;&#x2F;github.com&#x2F;levinhen&#x2F;levinhen.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>我是认为只需要将网站文件夹放到<code>master branch</code>就好了，<del>反正也不会去看repository不是吗?</del></p><p>至于后面的问题，关于主题更换、搜索栏、还有一些使用方法的记录，<del>等我想起来的时候再整吧。</del></p><h3 id="过程中间关于使用ssh与github建立连接的问题"><a href="#过程中间关于使用ssh与github建立连接的问题" class="headerlink" title="过程中间关于使用ssh与github建立连接的问题"></a>过程中间关于使用ssh与github建立连接的问题</h3><p>我在过程当中不知道为什么走岔路去使用ssh连接github了，看<a href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/connecting-to-github-with-ssh">官方文档</a>就能解决绝大部分问题了。我在将ssh秘钥添加到ssh-agent的时候后曾经有一个小问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Could not open a connection to your authentication agent</span><br><span class="line">只需要执行下列语句就可以顺利添加了：</span><br><span class="line">ssh-agent bash</span><br></pre></td></tr></table></figure><p>在中间，我的<code>git bash</code>的home位置不知道为什么是我之前做数电实验的<code>cadence</code>那儿，很奇怪。</p><h3 id="“生活小妙招”"><a href="#“生活小妙招”" class="headerlink" title="“生活小妙招”"></a>“生活小妙招”</h3><p>顺便记录一下“生活小妙招”，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有一些文件删不掉，需要权限，只需要移动到C盘的&#96;Program Files&#96;就可以直接删掉了</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在最前面&quot;&gt;&lt;a href=&quot;#写在最前面&quot; class=&quot;headerlink&quot; title=&quot;写在最前面&quot;&gt;&lt;/a&gt;写在最前面&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;记录在blog创建过程中出现的问题&quot;&gt;&lt;a href=&quot;#记录在blog创建过程中出现的问题&quot; </summary>
      
    
    
    
    
  </entry>
  
</feed>
