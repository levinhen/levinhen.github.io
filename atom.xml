<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>记录点滴</subtitle>
  <link href="https://levinhen.github.io/atom.xml" rel="self"/>
  
  <link href="https://levinhen.github.io/"/>
  <updated>2021-04-04T07:34:02.558Z</updated>
  <id>https://levinhen.github.io/</id>
  
  <author>
    <name>Levinhen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>游戏编程模式</title>
    <link href="https://levinhen.github.io/2021/04/04/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://levinhen.github.io/2021/04/04/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-04T07:34:02.000Z</published>
    <updated>2021-04-04T07:34:02.558Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>常用库函数总结(C++)</title>
    <link href="https://levinhen.github.io/2021/02/28/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93-C/"/>
    <id>https://levinhen.github.io/2021/02/28/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93-C/</id>
    <published>2021-02-28T12:50:08.000Z</published>
    <updated>2021-03-08T02:59:43.297Z</updated>
    
    <content type="html"><![CDATA[<p>以后会在这里记录常用的库函数，免得再重做轮子了。</p><h4 id="STL-STL源码剖析记得看"><a href="#STL-STL源码剖析记得看" class="headerlink" title="STL(STL源码剖析记得看)"></a>STL(STL源码剖析记得看)</h4><ul><li><code>switch</code>语句只判断整型数据类型的变量(包括<code>char</code>)</li><li><code>string</code>:<ul><li><code>stoi()</code>与<code>atoi()</code>都是将字符串转换成<code>int</code>类型进行输出的，不同的地方在于<code>atoi()</code>需要<code>const cahr*</code>，而<code>stoi()</code>需要<code>const string*</code>。因此，使用atoi的时候还需要再加一句<code>c_str()</code>将string类型转换为<code>const char*</code>类型的。</li><li><code>size_t find ( const string&amp; str, size_t pos = 0 ) const;</code>str为子字符串，pos为初始查找位置。</li><li><code>string substr ( size_t pos = 0, size_t len = npos ) const;</code>pos为起始位置（默认为0），len为字符串长度（默认为npos）</li></ul></li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul><li><code>front()</code>：在<code>stack</code>中的<code>top()</code>函数在<code>queue</code>中为<code>front()</code>函数</li><li></li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="hash-map-unordered-map"><a href="#hash-map-unordered-map" class="headerlink" title="hash_map == unordered_map"></a>hash_map == unordered_map</h4><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><ul><li>使用<code>stringstream + getline</code>来分割字符串<ul><li><code>stringstream</code>是流的输入输出操作，定义于<code>&lt;sstream&gt;</code>中。主要用来进行数据类型转换，避免缓冲区溢出，也不会存在错误的格式化符。</li><li><code>getline</code>原本是用于读取整行数据的，但是用于此处刚好也能用于分隔字符串。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以后会在这里记录常用的库函数，免得再重做轮子了。&lt;/p&gt;
&lt;h4 id=&quot;STL-STL源码剖析记得看&quot;&gt;&lt;a href=&quot;#STL-STL源码剖析记得看&quot; class=&quot;headerlink&quot; title=&quot;STL(STL源码剖析记得看)&quot;&gt;&lt;/a&gt;STL(STL源码剖析</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法题小结</title>
    <link href="https://levinhen.github.io/2021/02/03/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
    <id>https://levinhen.github.io/2021/02/03/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B0%8F%E7%BB%93/</id>
    <published>2021-02-03T13:26:41.000Z</published>
    <updated>2021-07-11T02:02:32.990Z</updated>
    
    <content type="html"><![CDATA[<h4 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h4><p>解题思想是使用滑动窗口，在这之中，运用字幕的ASCII码作为vector的索引挺让人眼前一亮。</p><p><img src="https://i.loli.net/2021/02/06/E5o1BhRjvaeVMit.png" alt="8b7cac826e572c65f8b77e0f380eaa93ab665857a8e916bc4ea36b7765eafc55-图片.png" title="滑动窗口"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; s.size(); j++) &#123;</span><br><span class="line">i = max(i, m[s[j]]);</span><br><span class="line">m[s[j]] = j + <span class="number">1</span>;</span><br><span class="line">ans = max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O($n^2$),空间复杂度为O(1)</p><h4 id="动态规划——最长回文子串"><a href="#动态规划——最长回文子串" class="headerlink" title="动态规划——最长回文子串"></a>动态规划——最长回文子串</h4><p>在邓公的书本上是没有发现动态规划相关内容的，我在<a href="https://www.zhihu.com/question/23995189">知乎的这里</a>发现了动态规划的讲解，非常通俗易懂。</p><p>在我理解的动态规划，就是另一种的贪心算法罢了？只不过动态规划是从小积累到大，强调记忆性，而贪心算法是将问题减而治之。</p><h4 id="不修改数组在-n-1-的数组中找出重复的数字"><a href="#不修改数组在-n-1-的数组中找出重复的数字" class="headerlink" title="不修改数组在[n+1]的数组中找出重复的数字"></a>不修改数组在[n+1]的数组中找出重复的数字</h4><p>在[n+1]数组中，想要不修改就找出数字，分为采用辅助数组和不采用两种方法。空间复杂度为O(n)和O(1)。只是不采用辅助数组要求数据的范围是1~n，换言之就是能确定一定有多余的数。</p><h4 id="寻找二进制数字的1的个数"><a href="#寻找二进制数字的1的个数" class="headerlink" title="寻找二进制数字的1的个数"></a>寻找二进制数字的1的个数</h4><p>在这样一个数字中，很容易想到的就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">除以2，除法速度非常慢</span><br><span class="line">往右移位，每次n位，且与n个1进行与运算，然而这种算法遇到负数就会溢出变成全为1的二进制数</span><br><span class="line">让做与运算的数往左移位，这样的方法能够有效避免溢出</span><br><span class="line">最好的方法是每次减1，然后与1做位运算</span><br><span class="line">##这种方法的时间复杂度比O(n)更小一点，目标数字有多少位1，方法所需要的处理次数就为多少</span><br></pre></td></tr></table></figure><h4 id="排序算法——最小的k个数"><a href="#排序算法——最小的k个数" class="headerlink" title="排序算法——最小的k个数"></a>排序算法——最小的k个数</h4><p><em>输入n个整数，找出其中最小的k个数</em></p><p>解法一：改进的快速排序</p><p>因为快速排序所得到的输出序列具有内在的大小顺位关系，于是想到是否可以舍弃这个大小关系以获得更快速的算法。在快速排序里面，每次排序完都会对哨兵的左、右子数组都进行递归，然而只需要对哨兵的index进行判断，判断是否为k，不相等时再相应对其中一侧递归的使用Partition函数即可。</p><p>解法二：不能更改数组时</p><p>选用一个合适的数据结构用以存放k个数，这样每次读取输入一个数只需要与现存的k个数中最大的数进行比较，小就替换，大就舍去。这个方法适用于海量的数据(不能全部存放在内存中的数据)，因为内存需要的空间只是k个数的空间。C++中以红黑树为基础的multiset就不失为好选择。</p><h4 id="二叉树与双向链表"><a href="#二叉树与双向链表" class="headerlink" title="二叉树与双向链表"></a>二叉树与双向链表</h4><p><em>将二叉树转变成双向链表</em></p><p>这道题没什么难的，就是出现了一个很奇怪的现象，在VisualStudio上能安全运行的代码居然在leetcode的在线编译器上报错了<code>member access within null pointer of type &#39;Node&#39;</code>下接代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">Node* left;</span><br><span class="line">Node* right;</span><br><span class="line"></span><br><span class="line">Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">val = _val;</span><br><span class="line">left = <span class="literal">NULL</span>;</span><br><span class="line">right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">int</span> _val, Node* _left, Node* _right) &#123;</span><br><span class="line">val = _val;</span><br><span class="line">left = _left;</span><br><span class="line">right = _right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">Node* Last_node = <span class="literal">nullptr</span>;</span><br><span class="line">BuildTree(root, &amp;Last_node);</span><br><span class="line"></span><br><span class="line">Node* head = Last_node;</span><br><span class="line"><span class="keyword">while</span> (head-&gt;left &amp;&amp; head) &#123;</span><br><span class="line">head = head-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(Node* node, Node** Last_node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">Node* current = node;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;left) BuildTree(current-&gt;left, Last_node);</span><br><span class="line">current-&gt;left = *Last_node;</span><br><span class="line"><span class="keyword">if</span> (*Last_node) (*Last_node)-&gt;right = current;</span><br><span class="line">*Last_node = current;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;right) BuildTree(current-&gt;right, Last_node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目前为止尚未弄明白这到底是怎么一回事。(初步推测是没有将整个双向链表的头和尾连接起来)</p><p>在leetcode的在线ide上这玩意又是接收了空指针又是栈溢出，很烦，然后再po一个能够运行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Node* head, *tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root); </span><br><span class="line">        head -&gt; left = tail; </span><br><span class="line">        tail -&gt; right = head; </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root -&gt; left);</span><br><span class="line">        <span class="keyword">if</span>(!tail) &#123;</span><br><span class="line">            head = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tail -&gt; right = root;</span><br><span class="line">            root -&gt; left = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = root;</span><br><span class="line">        inorder(root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="A-star-寻路算法"><a href="#A-star-寻路算法" class="headerlink" title="A-star 寻路算法"></a>A-star 寻路算法</h4><p>虽然不知道能不能算在算法题里面，但是就这么算了，事实上关于A星寻路算法，理解挺简单的。具体可以参考<a href="https://www.jianshu.com/p/65282bd32391">A-star</a>，然后是网友做出来的一个<a href="https://anseyuyin.github.io/AStar-Process/demo">算法可视化</a>。</p><p>感觉算法总体有一些优化空间，但是我暂时优化不出来，具体是关于怎么使用地图的整体。</p><h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><p>这个题目挺有趣的，第一个做法暴力解法超时了，看题解发现有三种方法可以做出来，这里只贴出我使用的单挑递减栈的代码。</p><p>一、双指针</p><p><img src="https://i.loli.net/2021/02/24/WFIejOzPrHUCxLR.png" alt="1614045759-jjZdVw-file_1614045758988.png"></p><p>在每一列寻找左侧最高柱与右侧最高柱，比较两者中的最小值再减去本列的高度乘以宽度1就是本列的雨水蓄积量了。</p><p>二、动态规划</p><p>当前位置，左边的最高高度，是前一个位置的最高高度和本高度的最大值。<br>即从左向右遍历：<code>maxLeft[i] = max(height[i], maxLeft[i - 1]);</code><br>从右向左遍历：<code>maxRight[i] = max(height[i], maxRight[i + 1]);</code><br>这样就找到递推公式。</p><p>三、单调递减栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.size(); i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() &amp;&amp; height[i] &gt; height[<span class="built_in">stack</span>.top()]) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="built_in">stack</span>.top();</span><br><span class="line"><span class="built_in">stack</span>.pop();</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> h = min(height[i], height[<span class="built_in">stack</span>.top()]) - height[mid];</span><br><span class="line"><span class="keyword">int</span> w = i - <span class="built_in">stack</span>.top() - <span class="number">1</span>;</span><br><span class="line">sum += h * w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stack</span>.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h4><p>想到使用栈去存储路径，但是其实用vector会更快，而且时间也更短。而且，可以使用 stringstream + getline 来分割字符串。</p><h4 id="区域和检索-数组不可变"><a href="#区域和检索-数组不可变" class="headerlink" title="区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">区域和检索 - 数组不可变</a></h4><p>一道很简单的题目，即使暴力也只有*O(n)<em>的时间复杂度，但是能够通过使用前缀和缩短至</em>O(1)*的时间复杂度。而且，我还看到一个关于分块的思想，在这里显然分块是没有用的，但是当数组需要修改其中一个值的时候，没有分块的话就需要修改整张前缀表，但是分块之后就只需要修改当前所在块。</p><h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></h4><p>在这一道题目中，我通过<code>deque</code>实现了单调队列，在我的理解范围内，这个偏向于是一种滚动的队列。</p><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p><h4 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/">比特位计数</a></h4><p>学到了布赖恩·克尼根算法(Brian Kernighan Algorithm)，本质上就是用<code>i&amp;(i-1)</code>刚好每次都比<code>i</code>的二进制数少1，上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(num + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                i = i &amp; (i - <span class="number">1</span>);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：threesr</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/counting-bits/solution/c-bu-lai-en-ke-ni-gen-suan-fa-dong-tai-g-17ym/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>然后结合DP的思想，就会得到一个更快的算法，这其中<code>i &amp; (i - 1)是比i的二进制少一个1的数值，这个数值对应的1的个数加1就是i对应的1的个数。</code>是关键所在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(num + <span class="number">1</span>)</span></span>;</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            result[i] = result[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/">解数独</a></h4><p>这一题就算用回溯法也有一定的难度，但是看到一个使用<code>bitset</code>的令人耳目一新的解法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">bitset</span>&lt;9&gt; <span class="title">getPossibleStatus</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ~(rows[x] | cols[y] | cells[x / <span class="number">3</span>][y / <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getNext</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> minCnt = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">auto</span> cur = getPossibleStatus(i, j);</span><br><span class="line">                <span class="keyword">if</span> (cur.count() &gt;= minCnt) <span class="keyword">continue</span>;</span><br><span class="line">                ret = &#123; i, j &#125;;</span><br><span class="line">                minCnt = cur.count();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fillNum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n, <span class="keyword">bool</span> fillFlag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rows[x][n] = (fillFlag) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        cols[y][n] = (fillFlag) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        cells[x/<span class="number">3</span>][y/<span class="number">3</span>][n] = (fillFlag) ? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> next = getNext(board);</span><br><span class="line">        <span class="keyword">auto</span> bits = getPossibleStatus(next[<span class="number">0</span>], next[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; bits.size(); n++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bits.test(n)) <span class="keyword">continue</span>;</span><br><span class="line">            fillNum(next[<span class="number">0</span>], next[<span class="number">1</span>], n, <span class="literal">true</span>);</span><br><span class="line">            board[next[<span class="number">0</span>]][next[<span class="number">1</span>]] = n + <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(board, cnt - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            board[next[<span class="number">0</span>]][next[<span class="number">1</span>]] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            fillNum(next[<span class="number">0</span>], next[<span class="number">1</span>], n, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rows = <span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;<span class="number">9</span>&gt;&gt;(<span class="number">9</span>, <span class="built_in">bitset</span>&lt;<span class="number">9</span>&gt;());</span><br><span class="line">        cols = <span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;<span class="number">9</span>&gt;&gt;(<span class="number">9</span>, <span class="built_in">bitset</span>&lt;<span class="number">9</span>&gt;());</span><br><span class="line">        cells = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;<span class="number">9</span>&gt;&gt;&gt;(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;<span class="number">9</span>&gt;&gt;(<span class="number">3</span>, <span class="built_in">bitset</span>&lt;<span class="number">9</span>&gt;()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt += (board[i][j] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> n = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                rows[i] |= (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">                cols[j] |= (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">                cells[i / <span class="number">3</span>][j / <span class="number">3</span>] |= (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;9&gt;&gt; rows;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;9&gt;&gt; cols;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;9&gt;&gt;&gt; cells;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：ikaruga</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/sudoku-solver/solution/37-by-ikaruga/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>存在<code>getNext</code>函数用于找到最容易出答案的位置，也就是已知信息最多的位置，就像模拟人类思考一样。而<code>getPossibleStatus</code>则是用以显示在这个位置上的信息量多少，这一串或运算非常巧妙。</p><p>然后<code>solveSudoku</code>初始化<code>bitset</code>的状态，作为函数主体的<code>dfs</code>就是回溯算法的主体了。<code>fillNum</code>的写法也非常巧妙，用以更新<code>bitset</code>的状态。</p><h4 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h4><p>考虑变式问题，如果题目给出的不是有序排列，那么就需要对整个无序数列进行异或，相同的数字异或会得到 000，最后剩下的就是所缺失的那个数字了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = nums.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.size()<span class="number">-1</span>; ++i)    </span><br><span class="line">res ^= nums[i] ^ i;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">作者：zrita</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/4xing-cyi-huo-z-by-zrita-ibgk/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h4><p>方法都很巧妙，比如说直接计算递推公式的和(使用内存进行计算)<code>sizeof(bool a[n][n - 1])&gt;&gt;1;</code></p><p>以及用逻辑短路来终止递归<code>n &amp;&amp; (n += sumNums(n-1));</code></p><h4 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">重复的子字符串</a></h4><p>是一道典型的KMP问题，但是能把代码写的简单又优美，一行就能搞定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s + s).find(s, <span class="number">1</span>) != s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">作者：da-li-wang</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/repeated-substring-pattern/solution/c-yi-xing-ti-jie-by-da-li-wang-3/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h4&gt;&lt;p&gt;解题思想是使用滑动窗口，在这之中，运用字幕的ASCII码作为vector的索</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++相关知识</title>
    <link href="https://levinhen.github.io/2021/02/03/C-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>https://levinhen.github.io/2021/02/03/C-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</id>
    <published>2021-02-03T06:19:49.000Z</published>
    <updated>2021-03-15T11:54:43.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-相关知识"><a href="#C-相关知识" class="headerlink" title="C++相关知识"></a>C++相关知识</h2><p>在做题的时候是Java和C++都有的，故复习一下C++。</p><p>1、箭头运算符和点运算符，点运算符的左侧对象为实例，箭头运算符为指针。</p><p>2、使用new初始化char[]的时候要+1，给<code>\0</code>预留位置。</p><p>3、在合并两个数组的时候，从前往后复制往往需要移动多次，但是从后往前移动就没有这种烦恼。</p><p>4、很显然的，在计算时少用乘除法，多用位运算，数学上等价的运算，效率上却有着千差万别。</p><p>5、在直接将字符数组中的数字转换成int型需要减一个<code>&#39;0&#39;</code>,这个是减去字符0的ascii码。</p><p>6、C++ STL库里的Partition函数与快速排序还是有点差别的。</p><p>7、<code>vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;&#125;&#125;;</code>如果直接使用<code>matrix.empty()</code>判断为非空。</p><p>8、日常使用的STL其实是经历过三版变化的。</p><ul><li>HP STL<ul><li>是C++最早的开源STL，以后的STL也是以HP STL为蓝本的。</li><li>日常使用的并不是最早的版本。</li></ul></li><li>P.J.Plauger STL<ul><li>由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li></ul></li><li>SGI STL<ul><li>日常使用的STL，由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li></ul></li></ul><p>9、栈和队列的底层实现(日后要把这一条搬一下位置，再把其他的底层实现都看一遍)</p><p>栈和队列的底层实现可以选用<code>deque</code>、<code>vector</code>、<code>list</code>，一般默认情况下都是使用<code>deque</code>，只需要将这种双端队列其中一端封住就可以了。</p><p>也因此，<code>stack</code>和<code>queue</code>并不属于容器，他们属于容器适配器。</p><p>10、NULL实际上是int类型，值为0，因为怕它具有二义性，而nullptr才是真正的空指针。</p><p>11、对一个已经为空的容器或者其他数据结构类型使用类似于pop的操作是不行的，需要在回溯法中注意这一点。</p><p>12、反斜杠<code>\</code>与斜杆<code>/</code>，在编程中反斜杠是转义字符的起始符号，所以一般使用双反斜杆<code>\\</code>来转义为单反斜杆<code>\</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-相关知识&quot;&gt;&lt;a href=&quot;#C-相关知识&quot; class=&quot;headerlink&quot; title=&quot;C++相关知识&quot;&gt;&lt;/a&gt;C++相关知识&lt;/h2&gt;&lt;p&gt;在做题的时候是Java和C++都有的，故复习一下C++。&lt;/p&gt;
&lt;p&gt;1、箭头运算符和点运算符，点运算</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java相关知识</title>
    <link href="https://levinhen.github.io/2021/02/02/java%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>https://levinhen.github.io/2021/02/02/java%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</id>
    <published>2021-02-02T03:22:22.000Z</published>
    <updated>2021-02-02T16:58:23.526Z</updated>
    
    <content type="html"><![CDATA[<p>这是在学习算法(第4版)里遇到的一些比较重要的知识点。</p><h2 id="Java篇"><a href="#Java篇" class="headerlink" title="Java篇"></a>Java篇</h2><h4 id="抽象数据类型的实现"><a href="#抽象数据类型的实现" class="headerlink" title="抽象数据类型的实现"></a>抽象数据类型的实现</h4><p>每个java类都至少含有一个构造函数，且其中的实例变量像是在一个普通的函数(C++)中的全局变量，但是是对每一个实例对象而言的。</p><p>关于api的考量，只为用例提供它们所需要的，这是设计api的指导思想。而在整个算法书中并不会使用接口继承，为了便于理解。但使用接口能方便进行比较和迭代。</p><p>Java的一个特点就是它不允许修改引用的策略，这种策略使Java能高效自动地回收垃圾。且有一个关键字<code>final</code>类似于C++的<code>const</code>，猜测由于没有指针的存在，故也没有顶层与底层的区别？但是感觉Java的引用和C++的指针在某些地方又有些重合的意味，有待深究。<br>姑且得到了答案，Java的引用被称作<strong>安全指针</strong>。因为对引用的创建于改变的方法都只有一种所以称为安全指针。</p><p>关于定容栈，书中提到Java是无法创建泛型数组的，需要使用类型转换，可是，难以理解这一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=(Item[]) <span class="keyword">new</span> Object[cap];</span><br></pre></td></tr></table></figure><p>书中提到了实现动态数组就是增与减，但是我觉得邓公的书更完善，并不一定每种情况的增量都是两倍，有些时候的确加固定值会更好。</p><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p>在给VS Code安装Java环境的时候，遇到了版本不匹配的问题，需要把旧版本删了，推荐用官方的删除工具，能把Java的高速缓存也清空了。<a href="https://www.java.com/zh-CN/download/uninstalltool.jsp">官网卸载工具</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是在学习算法(第4版)里遇到的一些比较重要的知识点。&lt;/p&gt;
&lt;h2 id=&quot;Java篇&quot;&gt;&lt;a href=&quot;#Java篇&quot; class=&quot;headerlink&quot; title=&quot;Java篇&quot;&gt;&lt;/a&gt;Java篇&lt;/h2&gt;&lt;h4 id=&quot;抽象数据类型的实现&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://levinhen.github.io/2021/01/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://levinhen.github.io/2021/01/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-01-25T08:37:43.000Z</published>
    <updated>2021-01-27T03:25:07.028Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统实际上的作用，取得物理资源(如CPU、内存与硬盘)，对它们虚拟化<code>virtualize</code>，处理与并发<code>concurrency</code>有关的问题，再持久地<code>persistently</code>存储文件。</p><p>在整个操作系统的过程中，抽象是非常重要的一个手段，有时候我们用了可能都不知道。</p><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>抽象：进程</p><p>渐渐的CPU虚拟化是看完了，可是在这些天刷题的过程中觉得还挺难，于是又回去看算法了。</p><hr><p>​                                            2021.1.27</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;操作系统实际上的作用，取得物理资源(如CPU、内存与硬盘)，对它们虚拟化&lt;code&gt;virtualize&lt;/code&gt;，处理与并发&lt;code&gt;concurrency&lt;/code&gt;有关的问题，再持久地&lt;code&gt;persistently&lt;/code&gt;存储文件。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法总结（一）</title>
    <link href="https://levinhen.github.io/2021/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://levinhen.github.io/2021/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-16T03:23:33.000Z</published>
    <updated>2021-01-27T08:33:07.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构与算法思想总结"><a href="#数据结构与算法思想总结" class="headerlink" title="数据结构与算法思想总结"></a>数据结构与算法思想总结</h2><p>我是跟着邓俊辉老师学习的数据结构与算法，第一次学习真的感觉视野增长了好多，很多数据结构以前都只是听过名字，也就是说有很多耳熟能详的名字，但却说不出个所以然。因此，通过邓老师的数据结构与算法入门之后，感觉还是非常的不错的。于是想在这里，重新回顾一遍我所学过的知识，也顺便总结一下。</p><p>这一次是想跟着挺有名的一本书叫algorithms的走一遍的，可是刚开始就要先学一小段java，后来想想打算把手头的任务都结束再去学一遍，毕竟算法学个几遍也不稀奇嘛。</p><p>说到底还是“得益”我没有做笔记，不得不重新再看一遍了。但是我也只是想做一做有关思想方面的总结，如果说全部的内容那真的算是很多了，如果有空再做吧。</p><h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><p>我觉得在绪论里面已经有很多很重要的思想了，所以我想单独谈一谈绪论。</p><p>在绪论里面，我们能够接触到关于<code>递归</code>与<code>迭代</code>的概念，这种重要的概念也不需要多做解释了吧。</p><p>值得一提的就是<code>尾递归</code>这种概念，算法中的所有实例都终止于此调用，才能称为尾递归，而尾递归是能一定能转化为迭代的形式的。关于递归，很多人的第一印象就是慢(虽然其实它并不是很慢)，但是慢的原因主要还是如下两点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fib():存在大量重复计算</span><br><span class="line">我们可以尝试通过：</span><br><span class="line">记忆:将计算过的实例制表备查</span><br><span class="line">动态规划:由自顶而下递归更改为自下而上迭代</span><br><span class="line">LCS:有歧义的存在</span><br></pre></td></tr></table></figure><p>随后是关于度量算法的好坏的，自然而然的，度量算法的好坏从时间与空间两种角度想，我们会采用渐进分析来尝试表示算法的复杂度。去用一个式子逼近想要得到的函数，这也时一种非常重要的思想。</p><p>在邓老师的课程中，关于计算的一种挺重要的手段就是<code>封底估算</code>，一些重要的估算结果很容易让人记住。就比如，<br>$$<br>一天约等于10^5秒，三生三世约等于10^{10}秒。<br>$$<br>然后还有关于问题的两种最经典的解决方式，<code>分而治之</code>与<code>减而治之</code>。这两种解决问题的方式其实也贯穿全书，也无需多做解释。</p><p>最后一个我认为最主要的思想就是<code>ADT(抽象数据类型)</code>遵循”数据隐藏”，就如同大家最喜欢的”黑盒子”思想，将实现细节隐藏，只保留对应的功能接口。这种模块化的思考方式，在我的电气学习旅途中也是最主要的思想。是将传统的数据以及组合的结构方式抽象出来，跳脱出语言的范畴，这种思想也是贯穿全书的。</p><h3 id="数据结构总结"><a href="#数据结构总结" class="headerlink" title="数据结构总结"></a>数据结构总结</h3><p>在我的理解中，各种各样的数据结构并不是毫无来由的，我们可以根据对性能或者成本的各种考量来催生出对应的各种数据结构。</p><h4 id="向量与列表"><a href="#向量与列表" class="headerlink" title="向量与列表"></a>向量与列表</h4><h5 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h5><p>第一次，我把详细的关于该数据结构的操作接口以及对应的实现完全实现一遍，而后面的数据结构我并不会再这样实现一遍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> rank;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFALUT_CAPACITY 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">rank _size; <span class="keyword">int</span> _capacity; T* _elem;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyfrom</span><span class="params">(T <span class="keyword">const</span>* A, rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shrink</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bubble</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">max</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionsort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">partition</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Vector(<span class="keyword">int</span> c = DEFALUT_CAPACITY, <span class="keyword">int</span> s = <span class="number">0</span>, T v = <span class="number">0</span>) &#123;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity = c];</span><br><span class="line"><span class="keyword">for</span> (_size = <span class="number">0</span>; _size &lt; s; _elem[_size++]);</span><br><span class="line">&#125;</span><br><span class="line">Vector(T <span class="keyword">const</span>* A, rank n) &#123; copyfrom(A, <span class="number">0</span>, n); &#125;</span><br><span class="line">Vector(T <span class="keyword">const</span>* A, rank lo, rank hi) &#123; copyfrom(A, lo, hi); &#125;</span><br><span class="line">Vector(Vector&lt;T&gt; <span class="keyword">const</span>&amp; V) &#123; copyfrom(V._elem, <span class="number">0</span>, V._size); &#125;</span><br><span class="line">Vector(Vector&lt;T&gt; <span class="keyword">const</span>&amp; V, rank lo, rank hi) &#123; copyfrom(V._elem, <span class="number">0</span>, V._size); &#125;</span><br><span class="line"></span><br><span class="line">~Vector()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] _elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">rank <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_size; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">disordered</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">find</span><span class="params">(T <span class="keyword">const</span>&amp; e)</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> find(e, <span class="number">0</span>, _size); &#125;</span><br><span class="line"><span class="function">rank <span class="title">find</span><span class="params">(T <span class="keyword">const</span>&amp; e, rank lo, rank hi)</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">search</span><span class="params">(T <span class="keyword">const</span>&amp; e)</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="number">0</span> &gt;= _size) ? <span class="number">-1</span> : search(e, <span class="number">0</span>, _size); &#125;</span><br><span class="line"><span class="function">rank <span class="title">search</span><span class="params">(T <span class="keyword">const</span>&amp; e, rank lo, rank hi)</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>[] (rank r)<span class="keyword">const</span>;</span><br><span class="line">Vector&lt;T&gt; &amp; <span class="keyword">operator</span>=(Vector&lt;T&gt; <span class="keyword">const</span>&amp;);</span><br><span class="line"><span class="function">rank <span class="title">remove</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">remove</span><span class="params">(rank r)</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">insert</span><span class="params">(rank r, T <span class="keyword">const</span>&amp; e)</span></span>;</span><br><span class="line"><span class="function">rank <span class="title">insert</span><span class="params">(T <span class="keyword">const</span>&amp; e)</span> </span>&#123; <span class="keyword">return</span> insert(_size, e); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123; sort(<span class="number">0</span>, _size); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsort</span><span class="params">(rank lo, rank hi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsort</span><span class="params">()</span> </span>&#123; unsort(<span class="number">0</span>,_size); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deduplicate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">( <span class="keyword">void</span> (*) ( T&amp; ) )</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VST&gt;<span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(VST&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在向量这一种数据结构中，特别地在有序向量这种数据结构中，我们能够”循秩访问”(call-by-rank)我想，这也是向量(数组)的特别之处了吧。</p><p>写到这突然想了想，觉得不想写了，这种总结性质的笔记果然我只适合存在脑子里，不适合大喇喇的写出来。</p><p>又开始看算法了，继续写。</p><p>在学习基础的java语法的时候，书里面有这样一段话：<code>变量关联的是指向对象的引用而非数据类型的值本身</code>还是挺难理解的。后来，查了查，嗯，这不就是返回地址嘛，类似于指针。但是关于实例方法与静态方法，始终有些疑惑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构与算法思想总结&quot;&gt;&lt;a href=&quot;#数据结构与算法思想总结&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法思想总结&quot;&gt;&lt;/a&gt;数据结构与算法思想总结&lt;/h2&gt;&lt;p&gt;我是跟着邓俊辉老师学习的数据结构与算法，第一次学习真的感觉视野增长了</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://levinhen.github.io/2021/01/14/hello-world/"/>
    <id>https://levinhen.github.io/2021/01/14/hello-world/</id>
    <published>2021-01-14T13:21:30.575Z</published>
    <updated>2021-01-14T14:38:02.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><hr><h3 id="记录在blog创建过程中出现的问题"><a href="#记录在blog创建过程中出现的问题" class="headerlink" title="记录在blog创建过程中出现的问题"></a>记录在blog创建过程中出现的问题</h3><p>首先，当然是blog的创立，我参考了很多，最后决定使用github的github pages服务，具体则是依靠Hexo建立的站点。</p><p>github pages可以使用Git来控制，不得不说这是相当方便了。</p><p>使用Hexo的过程在这：</p><p><code>npm install -g hexo-cli</code>  在这里可以选择是否局部安装<code>hexo</code>包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就几句简单的命令而已，随后再安装<code>hexo</code>的<code>git</code>安装包部分就完全OK了。之后的步骤就是配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: https:&#x2F;&#x2F;github.com&#x2F;levinhen&#x2F;levinhen.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>我是认为只需要将网站文件夹放到<code>master branch</code>就好了，<del>反正也不会去看repository不是吗?</del></p><p>至于后面的问题，关于主题更换、搜索栏、还有一些使用方法的记录，<del>等我想起来的时候再整吧。</del></p><h3 id="过程中间关于使用ssh与github建立连接的问题"><a href="#过程中间关于使用ssh与github建立连接的问题" class="headerlink" title="过程中间关于使用ssh与github建立连接的问题"></a>过程中间关于使用ssh与github建立连接的问题</h3><p>我在过程当中不知道为什么走岔路去使用ssh连接github了，看<a href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/connecting-to-github-with-ssh">官方文档</a>就能解决绝大部分问题了。我在将ssh秘钥添加到ssh-agent的时候后曾经有一个小问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Could not open a connection to your authentication agent</span><br><span class="line">只需要执行下列语句就可以顺利添加了：</span><br><span class="line">ssh-agent bash</span><br></pre></td></tr></table></figure><p>在中间，我的<code>git bash</code>的home位置不知道为什么是我之前做数电实验的<code>cadence</code>那儿，很奇怪。</p><h3 id="“生活小妙招”"><a href="#“生活小妙招”" class="headerlink" title="“生活小妙招”"></a>“生活小妙招”</h3><p>顺便记录一下“生活小妙招”，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有一些文件删不掉，需要权限，只需要移动到C盘的&#96;Program Files&#96;就可以直接删掉了</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在最前面&quot;&gt;&lt;a href=&quot;#写在最前面&quot; class=&quot;headerlink&quot; title=&quot;写在最前面&quot;&gt;&lt;/a&gt;写在最前面&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;记录在blog创建过程中出现的问题&quot;&gt;&lt;a href=&quot;#记录在blog创建过程中出现的问题&quot; </summary>
      
    
    
    
    
  </entry>
  
</feed>
